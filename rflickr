#!/usr/bin/env ruby
# frozen_string_literal: true

require 'pp'
require 'optparse'
require 'ostruct'
require 'json'
require 'date'
require 'dbm'
require 'erb'
require 'base64'
require 'geo/coord'

stags = []
o = OpenStruct.new
OptionParser.new do |opts|
  opts.on('-j JSON', 'Path to JSONs') { |j| o.j = j }
  opts.on('-o', 'Overwrite')          { o.ow = true }
  opts.on('-m', 'Merge XMP')          { o.mx = true }
  opts.on('-n', 'Dry run')            { o.dry = true }
  opts.on('-v', 'Verbose')            { o.v = true }
  opts.on('--vg', 'Verbose gps')      { o.vg = true }
  opts.on('--wd', 'XMP in work dir')  { o.wd = true }
  opts.on('--st TAG', 'Skip tag')     { |t| stags << t }
end.parse!

abort('provide path to jsons') unless o.j
abort("not a directory: #{o.j}") unless File.directory?(o.j)

require_relative 'rexmp' if o.mx

def geo_fmt s
  coord = s.insert(-7, '.')
  coord.sub(/-\./, '-0.')
end

class XmpWriter

  TK = 'github.com/porzione/flickr2xmp'

  def initialize
    @tpl = File.read('xmp.erb')
  end

  def write ih, filename
    ih[:title].encode!(xml: :text) if ih[:title]
    ih[:descr].encode!(xml: :text) if ih[:descr]
    ih[:tags].map! { |t| t.encode xml: :text }
    xmp = ERB.new(@tpl, nil, '-').result_with_hash ih.merge(tk: TK)
    File.open(filename, 'w') { |f| f.write(xmp) }
  end

end

xmp = XmpWriter.new
db = DBM.open('photo', nil, DBM::READER) || abort('Problem with db')

Dir.glob(File.join(o.j, 'photo_*.json')).each do |path|
  flickr = JSON.parse(File.read path).reject{|k,v| k == 'exif'}

  date = DateTime.strptime(flickr['date_taken'], '%Y-%m-%d %H:%M:%S')
  file = db[ date.to_time.to_i.to_s ]
  next unless file

  unless flickr['tags'].empty?
    tags = flickr['tags'].map{ |t| t['tag'] }
    tags.reject!{ |t| stags.include? t } unless stags.empty?
  end
  puts "#{file} #{tags}" if o.v

  fd = {
    url: flickr['photopage'],
    flickr_id: flickr['id'],
    flickr_views: flickr['count_views'],
    flickr_faves: flickr['count_faves']
  }

  fd[:albums] = flickr['albums'].map{|t| t['title']} if flickr['albums'].size > 0
  fd[:groups] = flickr['groups'].map{|t| t['name']} if flickr['groups'].size > 0
  fd[:comments] = flickr['comments'] if flickr['comments'].size > 0

  if flickr['geo']
    lat = geo_fmt flickr['geo']['latitude']
    lon = geo_fmt flickr['geo']['longitude']
    g = Geo::Coord.new lat, lon
    gps = {
      lat: g.strfcoord('%latd,%latm.%lats%lath'),
      lon: g.strfcoord('%lngd,%lngm.%lngs%lngh')
    }
    puts "https://www.google.com/maps/place/#{lat},#{lon} #{gps[:lat]},#{gps[:lon]}" if o.vg
  end
  next if o.dry

  bn = File.basename file
  ih = {
    file:    bn,
    title:   flickr['name'],
    data:    Base64.strict_encode64(JSON.generate(fd)),
    creator: ENV['USER'],
    tags:    tags,
    descr:   flickr['description'].empty? ? nil : flickr['description'],
    mdate:   DateTime.strptime(flickr['date_imported'], '%Y-%m-%d %H:%M:%S'),
    cdate:   date,
    gps:     gps
  }
  sidecar = "#{o.wd ? bn : file}.xmp"
  puts "sidecar: #{sidecar}" if o.v
  if File.exist?(sidecar)
    if o.ow
      xmp.write ih, sidecar
    elsif o.mx
      ReXMP.new(ih, sidecar)
    else
      STDERR.puts "sidecar exist: #{sidecar}"
    end
  else
    xmp.write ih, sidecar
  end

end

db.close

